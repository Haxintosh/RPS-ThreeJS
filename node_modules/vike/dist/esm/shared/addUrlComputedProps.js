// URLs props need to be computed props, because the user can modify the URL e.g. with onBeforeRoute() for i18n
export { addUrlComputedProps };
export { assertPageContextUrlComputedProps };
import { assert, parseUrl, assertWarning, isPlainObject, isPropertyGetter, isBrowser } from './utils.js';
function addUrlComputedProps(pageContext, enumerable = true) {
    assert(pageContext.urlOriginal);
    if ('urlPathname' in pageContext) {
        assert(typeof pageContext.urlPathname === 'string');
        /* If the following assert() fails then it's most likely because Object.assign() was used instead of objectAssign(), i.e.:
           ```js
           // Add property getters such as pageContext.urlPathname to pageContext
           addUrlComputedProps(pageContext)
           // ❌ Breaks the property getters of pageContext set by addUrlComputedProps() such as pageContext.urlPathname
           Object.assign(pageContext2, pageContext)
           // ❌ Also breaks the property getters
           const pageContext3 = { ...pageContext }
           // ✅ Preserves property getters of pageContext (see objectAssign() implementation)
           objectAssign(pageContext2, pageContext)
           ```
        */
        assert(isPropertyGetter(pageContext, 'urlPathname'));
    }
    if ('urlParsed' in pageContext)
        assert(isPropertyGetter(pageContext, 'urlParsed'));
    // TODO/v1-release: move pageContext.urlParsed to pageContext.url
    if ('url' in pageContext)
        assert(isPropertyGetter(pageContext, 'url'));
    Object.defineProperty(pageContext, 'urlPathname', {
        get: urlPathnameGetter,
        enumerable,
        configurable: true
    });
    Object.defineProperty(pageContext, 'url', {
        get: urlGetter,
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(pageContext, 'urlParsed', {
        get: urlParsedGetter,
        enumerable,
        configurable: true
    });
}
function getUrlParsed(pageContext) {
    // We need a url handler function because the onBeforeRoute() hook may set pageContext.urlLogical (typically for i18n)
    let urlHandler = pageContext._urlHandler;
    if (!urlHandler) {
        urlHandler = (url) => url;
    }
    // Example of i18n app using `throw render()`:
    //  1. User goes to '/fr-FR/admin'.
    //  2. The first onBeforeRoute() call accesses pageContext.urlPathname (its value is '/fr-FR/admin': the pathname of pageContext.urlOriginal, since both pageContext.urlLogical and pageContext._urlRewrite are undefined) and sets pageContext.urlLogical to '/admin'.
    //  3. A guard() hooks accesses pageContext.urlPathname (its value is '/admin': the pathname of pageContext.urlLogical) and calls `throw render('/fr-FR/login')`
    //  4. Vike create a new pageContext object (pageContext.urlLogical is erased) and sets pageContext._urlRewrite to '/fr-FR/login'. (While pageContext.urlOriginal is still '/fr-FR/admin'.)
    //  5. The second onBeforeRoute() call accesses pageContext.urlPathname (its value is '/fr-FR/login': the pathname of pageContext._urlRewrite, since pageContext.urlLogical is undefined) and sets pageContext.urlLogical to '/login'.
    //  6. The value of pageContext.urlPathname is now '/login': the pathname of `pageContext.urlLogical`. (While pageContext.urlOriginal is still '/fr-FR/admin'.)
    // Reproduction: https://github.com/vikejs/vike/discussions/1436#discussioncomment-8142023
    let urlResolved = 
    // Set by onBeforeRoute()
    pageContext.urlLogical ??
        // Set by `throw render()`
        pageContext._urlRewrite ??
        // Set by renderPage()
        pageContext.urlOriginal;
    urlResolved = urlHandler(urlResolved);
    /*
    console.log('pageContext.urlLogical', pageContext.urlLogical)
    console.log('pageContext._urlRewrite', pageContext._urlRewrite)
    console.log('pageContext.urlOriginal', pageContext.urlOriginal)
    console.log()
    //*/
    const baseServer = pageContext._baseServer;
    assert(urlResolved && typeof urlResolved === 'string');
    assert(baseServer.startsWith('/'));
    return parseUrl(urlResolved, baseServer);
}
function urlPathnameGetter() {
    const { pathname } = getUrlParsed(this);
    const urlPathname = pathname;
    assert(urlPathname.startsWith('/'));
    return urlPathname;
}
function urlGetter() {
    // TODO/v1-release: remove
    assertWarning(false, '`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)', { onlyOnce: true, showStackTrace: true });
    return urlPathnameGetter.call(this);
}
function urlParsedGetter() {
    const urlParsedOriginal = getUrlParsed(this);
    const { origin, pathname, pathnameOriginal, search, searchAll, searchOriginal, hash, hashOriginal } = urlParsedOriginal;
    const hashIsAvailable = isBrowser();
    const warnHashNotAvailable = (prop) => {
        assertWarning(hashIsAvailable, `pageContext.urlParsed.${prop} isn't available on the server-side (HTTP requests don't include the URL hash by design)`, { onlyOnce: true, showStackTrace: true });
    };
    const urlParsed = {
        origin,
        pathname,
        pathnameOriginal,
        search,
        searchAll,
        searchOriginal,
        get hash() {
            warnHashNotAvailable('hash');
            return hash;
        },
        get hashOriginal() {
            warnHashNotAvailable('hashOriginal');
            return hashOriginal;
        },
        get hashString() {
            assertWarning(false, 'pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal', {
                onlyOnce: true,
                showStackTrace: true
            });
            warnHashNotAvailable('hashString');
            return hashOriginal;
        },
        get searchString() {
            assertWarning(false, 'pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal', { onlyOnce: true, showStackTrace: true });
            return searchOriginal;
        }
    };
    makeNonEnumerable(urlParsed, 'hashString');
    makeNonEnumerable(urlParsed, 'searchString');
    if (!hashIsAvailable) {
        makeNonEnumerable(urlParsed, 'hash');
        makeNonEnumerable(urlParsed, 'hashOriginal');
    }
    return urlParsed;
}
function makeNonEnumerable(obj, prop) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    Object.defineProperty(obj, prop, { ...descriptor, enumerable: false });
}
function assertPageContextUrlComputedProps(pageContext) {
    assert(typeof pageContext.urlOriginal === 'string');
    assert(typeof pageContext.urlPathname === 'string');
    assert(isPlainObject(pageContext.urlParsed));
    assert(pageContext.urlPathname === pageContext.urlParsed.pathname);
}
