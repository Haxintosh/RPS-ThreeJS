"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearFilesEnvMap = exports.assertImportPath = exports.resolveImportPath = exports.resolveImport = void 0;
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const utils_js_1 = require("../../../../utils.js");
const transformFileImports_js_1 = require("./transformFileImports.js");
const path_1 = __importDefault(require("path"));
const filesEnvMap = new Map();
function resolveImport(configValue, importerFilePath, userRootDir, configEnv, configName) {
    if (typeof configValue !== 'string')
        return null;
    const importData = (0, transformFileImports_js_1.parseImportData)(configValue);
    if (!importData)
        return null;
    const { importPath, exportName } = importData;
    const filePathAbsoluteFilesystem = resolveImportPath(importData, importerFilePath);
    assertFileEnv(filePathAbsoluteFilesystem ?? importPath, configEnv, configName);
    const fileExportPathToShowToUser = exportName === 'default' || exportName === configName ? [] : [exportName];
    if (importPath.startsWith('.')) {
        // We need to resolve relative paths into absolute paths. Because the import paths are included in virtual files:
        // ```
        // [vite] Internal server error: Failed to resolve import "./onPageTransitionHooks" from "virtual:vike:pageConfigValuesAll:client:/pages/index". Does the file exist?
        // ```
        assertImportPath(filePathAbsoluteFilesystem, importData, importerFilePath);
        const filePathRelativeToUserRootDir = resolveImportPath_relativeToUserRootDir(filePathAbsoluteFilesystem, importData, importerFilePath, userRootDir);
        const filePath = {
            filePathAbsoluteFilesystem,
            filePathRelativeToUserRootDir,
            filePathAbsoluteVite: filePathRelativeToUserRootDir,
            filePathToShowToUser: filePathRelativeToUserRootDir,
            importPathAbsolute: null
        };
        return {
            ...filePath,
            fileExportName: exportName,
            fileExportPathToShowToUser
        };
    }
    else {
        // importPath can be:
        //  - an npm package import
        //  - a path alias
        const filePath = {
            filePathAbsoluteFilesystem,
            filePathRelativeToUserRootDir: null,
            filePathAbsoluteVite: importPath,
            filePathToShowToUser: importPath,
            importPathAbsolute: importPath
        };
        return {
            ...filePath,
            fileExportName: exportName,
            fileExportPathToShowToUser
        };
    }
}
exports.resolveImport = resolveImport;
function resolveImportPath_relativeToUserRootDir(filePathAbsoluteFilesystem, importData, configFilePath, userRootDir) {
    (0, utils_js_1.assertPosixPath)(userRootDir);
    let filePathRelativeToUserRootDir;
    if (filePathAbsoluteFilesystem.startsWith(userRootDir)) {
        filePathRelativeToUserRootDir = getVitePathFromAbsolutePath(filePathAbsoluteFilesystem, userRootDir);
    }
    else {
        (0, utils_js_1.assertUsage)(false, `${configFilePath.filePathToShowToUser} imports from a relative path ${picocolors_1.default.cyan(importData.importPath)} outside of ${userRootDir} which is forbidden: import from a relative path inside ${userRootDir}, or import from a dependency's package.json#exports entry instead`);
        // None of the following works. Seems to be a Vite bug?
        // /*
        // assert(filePathAbsoluteFilesystem.startsWith('/'))
        // filePath = `/@fs${filePathAbsoluteFilesystem}`
        // /*/
        // filePathRelativeToUserRootDir = path.posix.relative(userRootDir, filePathAbsoluteFilesystem)
        // assert(filePathRelativeToUserRootDir.startsWith('../'))
        // filePathRelativeToUserRootDir = '/' + filePathRelativeToUserRootDir
        // //*/
    }
    (0, utils_js_1.assertPosixPath)(filePathRelativeToUserRootDir);
    (0, utils_js_1.assert)(filePathRelativeToUserRootDir.startsWith('/'));
    return filePathRelativeToUserRootDir;
}
function resolveImportPath(importData, importerFilePath) {
    const importerFilePathAbsolute = importerFilePath.filePathAbsoluteFilesystem;
    (0, utils_js_1.assertPosixPath)(importerFilePathAbsolute);
    const cwd = path_1.default.posix.dirname(importerFilePathAbsolute);
    // We can't use import.meta.resolve() as of Junary 2023 (and probably for a lot longer): https://stackoverflow.com/questions/54977743/do-require-resolve-for-es-modules#comment137174954_62272600:~:text=But%20the%20argument%20parent%20(aka%20cwd)%20still%20requires%20a%20flag
    // filePathAbsoluteFilesystem is expected to be null when importData.importPath is a Vite path alias
    const filePathAbsoluteFilesystem = (0, utils_js_1.requireResolve)(importData.importPath, cwd);
    return filePathAbsoluteFilesystem;
}
exports.resolveImportPath = resolveImportPath;
function assertImportPath(filePathAbsoluteFilesystem, importData, importerFilePath) {
    const { importPath: importPath, importStringWasGenerated, importString } = importData;
    const { filePathToShowToUser } = importerFilePath;
    if (!filePathAbsoluteFilesystem) {
        const importPathString = picocolors_1.default.cyan(`'${importPath}'`);
        const errIntro = importStringWasGenerated
            ? `The import path ${importPathString} in ${filePathToShowToUser}`
            : `The import ${picocolors_1.default.cyan(importString)} defined in ${filePathToShowToUser}`;
        const errIntro2 = `${errIntro} couldn't be resolved: does ${importPathString}`;
        if (importPath.startsWith('.')) {
            (0, utils_js_1.assertUsage)(false, `${errIntro2} point to an existing file?`);
        }
        else {
            (0, utils_js_1.assertUsage)(false, `${errIntro2} exist?`);
        }
    }
}
exports.assertImportPath = assertImportPath;
function assertFileEnv(filePathForEnvCheck, configEnv, configName) {
    (0, utils_js_1.assertPosixPath)(filePathForEnvCheck);
    if (!filesEnvMap.has(filePathForEnvCheck)) {
        filesEnvMap.set(filePathForEnvCheck, []);
    }
    const fileEnv = filesEnvMap.get(filePathForEnvCheck);
    fileEnv.push({ configEnv, configName });
    const configDifferentEnv = fileEnv.filter((c) => !(0, utils_js_1.deepEqual)(c.configEnv, configEnv))[0];
    if (configDifferentEnv) {
        (0, utils_js_1.assertUsage)(false, [
            `${filePathForEnvCheck} defines the value of configs living in different environments:`,
            ...[configDifferentEnv, { configName, configEnv }].map((c) => `  - config ${picocolors_1.default.cyan(c.configName)} which value lives in environment ${picocolors_1.default.cyan(JSON.stringify(c.configEnv))}`),
            'Defining config values in the same file is allowed only if they live in the same environment, see https://vike.dev/header-file'
        ].join('\n'));
    }
}
function clearFilesEnvMap() {
    filesEnvMap.clear();
}
exports.clearFilesEnvMap = clearFilesEnvMap;
function getVitePathFromAbsolutePath(filePathAbsoluteFilesystem, root) {
    (0, utils_js_1.assertPosixPath)(filePathAbsoluteFilesystem);
    (0, utils_js_1.assertPosixPath)(root);
    (0, utils_js_1.assert)(filePathAbsoluteFilesystem.startsWith(root));
    let vitePath = path_1.default.posix.relative(root, filePathAbsoluteFilesystem);
    (0, utils_js_1.assert)(!vitePath.startsWith('/') && !vitePath.startsWith('.'));
    vitePath = '/' + vitePath;
    return vitePath;
}
