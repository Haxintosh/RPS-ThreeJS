"use strict";
// Files loadded at config time:
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfigFile = exports.loadValueFile = exports.loadImportedFile = void 0;
const utils_js_1 = require("../../../../utils.js");
const transpileAndExecuteFile_js_1 = require("./transpileAndExecuteFile.js");
const assertPlusFileExport_js_1 = require("../../../../../../shared/page-configs/assertPlusFileExport.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const transformFileImports_js_1 = require("./transformFileImports.js");
const getConfigFileExport_js_1 = require("../getConfigFileExport.js");
const resolveImportPath_js_1 = require("./resolveImportPath.js");
(0, utils_js_1.assertIsNotProductionRuntime)();
// Load fake import
async function loadImportedFile(import_, userRootDir, importedFilesLoaded) {
    const f = import_.filePathAbsoluteFilesystem;
    if (!importedFilesLoaded[f]) {
        importedFilesLoaded[f] = (0, transpileAndExecuteFile_js_1.transpileAndExecuteFile)(import_, false, userRootDir).then((r) => r.fileExports);
    }
    const fileExports = await importedFilesLoaded[f];
    const fileExport = fileExports[import_.fileExportName];
    return fileExport;
}
exports.loadImportedFile = loadImportedFile;
// Load +{configName}.js
async function loadValueFile(interfaceValueFile, configName, userRootDir) {
    const { fileExports } = await (0, transpileAndExecuteFile_js_1.transpileAndExecuteFile)(interfaceValueFile.filePath, false, userRootDir);
    const { filePathToShowToUser } = interfaceValueFile.filePath;
    (0, assertPlusFileExport_js_1.assertPlusFileExport)(fileExports, filePathToShowToUser, configName);
    Object.entries(fileExports).forEach(([exportName, configValue]) => {
        const configName_ = exportName === 'default' ? configName : exportName;
        interfaceValueFile.fileExportsByConfigName[configName_] = { configValue };
    });
}
exports.loadValueFile = loadValueFile;
// Load +config.js, including all its extends fake imports
async function loadConfigFile(configFilePath, userRootDir, visited, isConfigOfExtension) {
    const { filePathAbsoluteFilesystem } = configFilePath;
    assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem);
    const { fileExports } = await (0, transpileAndExecuteFile_js_1.transpileAndExecuteFile)(configFilePath, !isConfigOfExtension, userRootDir, isConfigOfExtension);
    const { extendsConfigs, extendsFilePaths } = await loadExtendsConfigs(fileExports, configFilePath, userRootDir, [
        ...visited,
        filePathAbsoluteFilesystem
    ]);
    const configFile = {
        fileExports,
        filePath: configFilePath,
        extendsFilePaths
    };
    return { configFile, extendsConfigs };
}
exports.loadConfigFile = loadConfigFile;
function assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem) {
    const idx = visited.indexOf(filePathAbsoluteFilesystem);
    if (idx === -1)
        return;
    const loop = visited.slice(idx);
    (0, utils_js_1.assert)(loop[0] === filePathAbsoluteFilesystem);
    (0, utils_js_1.assertUsage)(idx === -1, `Infinite extends loop ${[...loop, filePathAbsoluteFilesystem].join('>')}`);
}
async function loadExtendsConfigs(configFileExports, configFilePath, userRootDir, visited) {
    const extendsImportData = getExtendsImportData(configFileExports, configFilePath);
    const extendsConfigFiles = [];
    extendsImportData.map((importData) => {
        const { importPath: importPath } = importData;
        const filePathAbsoluteFilesystem = (0, resolveImportPath_js_1.resolveImportPath)(importData, configFilePath);
        (0, resolveImportPath_js_1.assertImportPath)(filePathAbsoluteFilesystem, importData, configFilePath);
        warnUserLandExtension(importPath, configFilePath);
        // - filePathRelativeToUserRootDir has no functionality beyond nicer error messages for user
        // - Using importPath would be visually nicer but it's ambigous => we rather pick filePathAbsoluteFilesystem for added clarity
        const filePathRelativeToUserRootDir = determineFilePathRelativeToUserDir(filePathAbsoluteFilesystem, userRootDir);
        const filePathAbsoluteVite = filePathRelativeToUserRootDir ?? importPath;
        extendsConfigFiles.push({
            filePathAbsoluteFilesystem,
            filePathAbsoluteVite,
            filePathRelativeToUserRootDir,
            filePathToShowToUser: filePathAbsoluteVite,
            importPathAbsolute: importPath
        });
    });
    const extendsConfigs = [];
    await Promise.all(extendsConfigFiles.map(async (configFilePath) => {
        const result = await loadConfigFile(configFilePath, userRootDir, visited, true);
        extendsConfigs.push(result.configFile);
        extendsConfigs.push(...result.extendsConfigs);
    }));
    const extendsFilePaths = extendsConfigFiles.map((f) => f.filePathAbsoluteFilesystem);
    return { extendsConfigs, extendsFilePaths };
}
function determineFilePathRelativeToUserDir(filePathAbsoluteFilesystem, userRootDir) {
    (0, utils_js_1.assertPosixPath)(filePathAbsoluteFilesystem);
    (0, utils_js_1.assertPosixPath)(userRootDir);
    if (!filePathAbsoluteFilesystem.startsWith(userRootDir)) {
        return null;
    }
    let filePathRelativeToUserRootDir = filePathAbsoluteFilesystem.slice(userRootDir.length);
    if (!filePathRelativeToUserRootDir.startsWith('/'))
        filePathRelativeToUserRootDir = '/' + filePathRelativeToUserRootDir;
    return filePathRelativeToUserRootDir;
}
function warnUserLandExtension(importPath, configFilePath) {
    (0, utils_js_1.assertWarning)((0, utils_js_1.isNpmPackageImport)(importPath), `${configFilePath.filePathToShowToUser} uses ${picocolors_1.default.cyan('extends')} to inherit from ${picocolors_1.default.cyan(importPath)} which is a user-land file: this is experimental and may be remove at any time. Reach out to a maintainer if you need this.`, { onlyOnce: true });
}
function getExtendsImportData(configFileExports, configFilePath) {
    const { filePathToShowToUser } = configFilePath;
    const configFileExport = (0, getConfigFileExport_js_1.getConfigFileExport)(configFileExports, filePathToShowToUser);
    const wrongUsage = `${filePathToShowToUser} sets the config ${picocolors_1.default.cyan('extends')} to an invalid value, see https://vike.dev/extends`;
    let extendList;
    if (!('extends' in configFileExport)) {
        return [];
    }
    else if ((0, utils_js_1.hasProp)(configFileExport, 'extends', 'string')) {
        extendList = [configFileExport.extends];
    }
    else if ((0, utils_js_1.hasProp)(configFileExport, 'extends', 'string[]')) {
        extendList = configFileExport.extends;
    }
    else {
        (0, utils_js_1.assertUsage)(false, wrongUsage);
    }
    const extendsImportData = extendList.map((importDataSerialized) => {
        const importData = (0, transformFileImports_js_1.parseImportData)(importDataSerialized);
        (0, utils_js_1.assertUsage)(importData, wrongUsage);
        return importData;
    });
    return extendsImportData;
}
