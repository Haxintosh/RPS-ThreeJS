"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTmpFile = exports.getConfigExecutionErrorIntroMsg = exports.getConfigBuildErrorFormatted = exports.transpileAndExecuteFile = void 0;
const esbuild_1 = require("esbuild");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const import_1 = require("@brillout/import");
const utils_js_1 = require("../../../../utils.js");
const transformFileImports_js_1 = require("./transformFileImports.js");
const getVikeConfig_js_1 = require("../getVikeConfig.js");
require("source-map-support/register.js");
const getConfigFileExport_js_1 = require("../getConfigFileExport.js");
(0, utils_js_1.assertIsNotProductionRuntime)();
async function transpileAndExecuteFile(filePath, transformImports, userRootDir, doNotTranspile = false) {
    if (doNotTranspile) {
        (0, utils_js_1.assert)(!transformImports);
        const fileExports = await executeFile(filePath.filePathAbsoluteFilesystem, filePath);
        if (isHeaderFile(filePath.filePathAbsoluteFilesystem)) {
            const filePathToShowToUser2 = getFilePathToShowToUser2(filePath);
            (0, utils_js_1.assertWarning)(false, `${filePathToShowToUser2} is a JavaScript header file (.h.js), but JavaScript header files don't apply to the config files of extensions`, { onlyOnce: true });
        }
        return { fileExports };
    }
    else {
        const { code, fileImportsTransformed } = await transpileFile(filePath, transformImports, userRootDir);
        const fileExports = await executeTranspiledFile(filePath, code, fileImportsTransformed);
        return { fileExports };
    }
}
exports.transpileAndExecuteFile = transpileAndExecuteFile;
async function transpileFile(filePath, transformImports, userRootDir) {
    const { filePathAbsoluteFilesystem } = filePath;
    const filePathToShowToUser2 = getFilePathToShowToUser2(filePath);
    (0, utils_js_1.assertPosixPath)(filePathAbsoluteFilesystem);
    getVikeConfig_js_1.vikeConfigDependencies.add(filePathAbsoluteFilesystem);
    let code = await transpileWithEsbuild(filePath, userRootDir, transformImports);
    let fileImportsTransformed = null;
    if (transformImports) {
        const res = transformFileImports_(code, filePath);
        if (res) {
            code = res.code;
            fileImportsTransformed = res.fileImportsTransformed;
        }
    }
    else {
        if (isHeaderFile(filePathAbsoluteFilesystem)) {
            (0, utils_js_1.assertWarning)(false, `${filePathToShowToUser2} is a JavaScript header file (.h.js), but JavaScript header files only apply to +config.h.js, see https://vike.dev/header-file`, { onlyOnce: true });
        }
    }
    return { code, fileImportsTransformed };
}
function transformFileImports_(codeOriginal, filePath) {
    const { filePathAbsoluteFilesystem } = filePath;
    const filePathToShowToUser2 = getFilePathToShowToUser2(filePath);
    // Replace import statements with import strings
    const res = (0, transformFileImports_js_1.transformFileImports)(codeOriginal, filePathToShowToUser2);
    if (res.noTransformation) {
        return null;
    }
    const { code, fileImportsTransformed } = res;
    if (!isHeaderFile(filePathAbsoluteFilesystem)) {
        const filePathCorrect = appendHeaderFileExtension(filePathToShowToUser2);
        (0, utils_js_1.assertWarning)(false, `Rename ${filePathToShowToUser2} to ${filePathCorrect}, see https://vike.dev/header-file`, {
            onlyOnce: true
        });
    }
    return { code, fileImportsTransformed };
}
async function transpileWithEsbuild(filePath, userRootDir, transformImports) {
    const entryFilePath = filePath.filePathAbsoluteFilesystem;
    const entryFileDir = path_1.default.posix.dirname(entryFilePath);
    const options = {
        platform: 'node',
        entryPoints: [entryFilePath],
        sourcemap: 'inline',
        write: false,
        target: ['node14.18', 'node16'],
        outfile: path_1.default.posix.join(
        // Needed for correct inline source map
        entryFileDir, 
        // `write: false` => no file is actually be emitted
        'NEVER_EMITTED.js'),
        logLevel: 'silent',
        format: 'esm',
        absWorkingDir: userRootDir,
        // Disable tree-shaking to avoid dead-code elimination, so that unused imports aren't removed.
        // Esbuild still sometimes removes unused imports because of TypeScript: https://github.com/evanw/esbuild/issues/3034
        treeShaking: false,
        minify: false,
        metafile: !transformImports,
        // We cannot bundle imports that are meant to be transformed
        bundle: !transformImports
    };
    // Track dependencies
    if (!transformImports) {
        options.packages = 'external';
        options.plugins = [
            {
                name: 'vike:dependency-tracker',
                setup(b) {
                    b.onLoad({ filter: /./ }, (args) => {
                        // We collect the dependency `args.path` in case the bulid fails (upon build error => error is thrown => no metafile)
                        let { path } = args;
                        path = (0, utils_js_1.toPosixPath)(path);
                        getVikeConfig_js_1.vikeConfigDependencies.add(path);
                        return undefined;
                    });
                    /* To exhaustively collect all dependencies upon build failure, we would also need to use onResolve().
                     *  - Because onLoad() isn't call if the config dependency can't be resolved.
                     *  - For example, the following breaks auto-reload (the config is stuck in its error state and the user needs to touch the importer for the config to reload):
                     *    ```bash
                     *    mv ./some-config-dependency.js /tmp/ && mv /tmp/some-config-dependency.js .
                     *    ```
                     *  - But implementing a fix is complex and isn't worth it.
                    b.onResolve(...)
                    */
                }
            }
        ];
    }
    let result;
    try {
        result = await (0, esbuild_1.build)(options);
    }
    catch (err) {
        await formatBuildErr(err, filePath);
        throw err;
    }
    // Track dependencies
    if (!transformImports) {
        (0, utils_js_1.assert)(result.metafile);
        Object.keys(result.metafile.inputs).forEach((filePathRelative) => {
            filePathRelative = (0, utils_js_1.toPosixPath)(filePathRelative);
            (0, utils_js_1.assertPosixPath)(userRootDir);
            const filePathAbsoluteFilesystem = path_1.default.posix.join(userRootDir, filePathRelative);
            getVikeConfig_js_1.vikeConfigDependencies.add(filePathAbsoluteFilesystem);
        });
    }
    const code = result.outputFiles[0].text;
    (0, utils_js_1.assert)(typeof code === 'string');
    return code;
}
async function executeTranspiledFile(filePath, code, fileImportsTransformed) {
    const { filePathAbsoluteFilesystem, filePathRelativeToUserRootDir } = filePath;
    // Alternative to using a temporary file: https://github.com/vitejs/vite/pull/13269
    //  - But seems to break source maps, so I don't think it's worth it
    const filePathTmp = getFilePathTmp(filePathAbsoluteFilesystem);
    fs_1.default.writeFileSync(filePathTmp, code);
    const clean = () => fs_1.default.unlinkSync(filePathTmp);
    let fileExports = {};
    try {
        fileExports = await executeFile(filePathTmp, filePath);
    }
    finally {
        clean();
    }
    if (fileImportsTransformed) {
        (0, utils_js_1.assert)(filePathRelativeToUserRootDir !== undefined);
        const filePathToShowToUser2 = getFilePathToShowToUser2(filePath);
        assertImportsAreReExported(fileImportsTransformed, fileExports, filePathToShowToUser2);
    }
    return fileExports;
}
async function executeFile(filePathToExecuteAbsoluteFilesystem, filePathSourceFile) {
    let fileExports = {};
    try {
        fileExports = await (0, import_1.import_)(filePathToExecuteAbsoluteFilesystem);
    }
    catch (err) {
        triggerPrepareStackTrace(err);
        const errIntroMsg = getErrIntroMsg('execute', filePathSourceFile);
        (0, utils_js_1.assert)((0, utils_js_1.isObject)(err));
        execErrIntroMsg.set(err, errIntroMsg);
        throw err;
    }
    // Return a plain JavaScript object:
    //  - import() returns `[Module: null prototype] { default: { onRenderClient: '...' }}`
    //  - We don't need this special object.
    fileExports = { ...fileExports };
    return fileExports;
}
const formatted = '_formatted';
function getConfigBuildErrorFormatted(err) {
    if (!(0, utils_js_1.isObject)(err))
        return null;
    if (!(formatted in err))
        return null;
    (0, utils_js_1.assert)(typeof err[formatted] === 'string');
    return err[formatted];
}
exports.getConfigBuildErrorFormatted = getConfigBuildErrorFormatted;
async function formatBuildErr(err, filePath) {
    (0, utils_js_1.assert)((0, utils_js_1.isObject)(err) && err.errors);
    const msgEsbuild = (await (0, esbuild_1.formatMessages)(err.errors, {
        kind: 'error',
        color: true
    }))
        .map((m) => m.trim())
        .join('\n');
    const msgIntro = getErrIntroMsg('transpile', filePath);
    err[formatted] = `${msgIntro}\n${msgEsbuild}`;
}
const execErrIntroMsg = new WeakMap();
function getConfigExecutionErrorIntroMsg(err) {
    if (!(0, utils_js_1.isObject)(err))
        return null;
    const errIntroMsg = execErrIntroMsg.get(err);
    return errIntroMsg ?? null;
}
exports.getConfigExecutionErrorIntroMsg = getConfigExecutionErrorIntroMsg;
const tmpPrefix = `[build-`;
function getFilePathTmp(filePathAbsoluteFilesystem) {
    (0, utils_js_1.assertPosixPath)(filePathAbsoluteFilesystem);
    const dirname = path_1.default.posix.dirname(filePathAbsoluteFilesystem);
    const filename = path_1.default.posix.basename(filePathAbsoluteFilesystem);
    // Syntax with semicolon `[build:${/*...*/}]` doesn't work on Windows: https://github.com/vikejs/vike/issues/800#issuecomment-1517329455
    const tag = `${tmpPrefix}${(0, utils_js_1.getRandomId)(12)}]`;
    const filePathTmp = path_1.default.posix.join(dirname, `${tag}${filename}.mjs`);
    return filePathTmp;
}
function isTmpFile(filePath) {
    (0, utils_js_1.assertPosixPath)(filePath);
    const fileName = path_1.default.posix.basename(filePath);
    return fileName.startsWith(tmpPrefix);
}
exports.isTmpFile = isTmpFile;
function assertImportsAreReExported(fileImportsTransformed, fileExports, filePathToShowToUser2) {
    const fileExport = (0, getConfigFileExport_js_1.getConfigFileExport)(fileExports, filePathToShowToUser2);
    const exportedStrings = getExportedStrings(fileExport);
    Object.values(exportedStrings).forEach((exportVal) => {
        if (typeof exportVal !== 'string')
            return;
        if (!(0, transformFileImports_js_1.isImportData)(exportVal))
            return;
        const importString = exportVal;
        fileImportsTransformed.forEach((fileImport) => {
            if (fileImport.importString === importString) {
                fileImport.isReExported = true;
            }
        });
    });
    const fileImportsTransformedUnused = fileImportsTransformed.filter((fi) => !fi.isReExported);
    if (fileImportsTransformedUnused.length === 0)
        return;
    const importStatements = (0, utils_js_1.unique)(fileImportsTransformedUnused.map((fi) => fi.importStatementCode));
    const importNamesUnused = fileImportsTransformedUnused.map((fi) => picocolors_1.default.cyan(fi.importLocalName)).join(', ');
    const singular = fileImportsTransformedUnused.length === 1;
    (0, utils_js_1.assertWarning)(fileImportsTransformedUnused.length === 0, [
        `${filePathToShowToUser2} imports the following:`,
        ...importStatements.map((s) => picocolors_1.default.cyan(`  ${s}`)),
        `But the import${singular ? '' : 's'} ${importNamesUnused} ${singular ? "isn't" : "aren't"} re-exported at ${picocolors_1.default.cyan('export default { ... }')} and therefore ${singular ? 'has' : 'have'} no effect, see explanation at https://vike.dev/header-file`
    ].join('\n'), { onlyOnce: true });
}
function getExportedStrings(obj) {
    const exportedStrings = [];
    Object.values(obj).forEach((val) => {
        if (typeof val === 'string') {
            exportedStrings.push(val);
        }
        else if (Array.isArray(val)) {
            val.forEach((v) => {
                if (typeof v === 'string') {
                    exportedStrings.push(v);
                }
            });
        }
    });
    return exportedStrings;
}
function isHeaderFile(filePath) {
    (0, utils_js_1.assertPosixPath)(filePath);
    const basenameParts = path_1.default.posix.basename(filePath).split('.');
    return basenameParts.includes('h');
}
function appendHeaderFileExtension(filePath) {
    const basenameParts = path_1.default.posix.basename(filePath).split('.');
    basenameParts.splice(-1, 0, 'h');
    const basenameCorrect = basenameParts.join('.');
    return path_1.default.posix.join(path_1.default.posix.dirname(filePath), basenameCorrect);
}
// Needed for the npm package 'source-map-support'. The Error.prepareStackTrace() hook of 'source-map-support' needs to be called before the file containing the source map is removed. The clean() call above removes the transpiled file from disk but it contains the inline source map.
function triggerPrepareStackTrace(err) {
    if ((0, utils_js_1.isObject)(err)) {
        // Accessing err.stack triggers prepareStackTrace()
        const { stack } = err;
        // Ensure no compiler removes the line above
        if (1 + 1 === 3)
            console.log('I_AM_NEVER_SHOWN' + stack);
    }
}
function getErrIntroMsg(operation, filePath) {
    const filePathToShowToUser2 = getFilePathToShowToUser2(filePath);
    const msg = [
        // prettier ignore
        picocolors_1.default.red(`Failed to ${operation}`),
        picocolors_1.default.bold(picocolors_1.default.red(filePathToShowToUser2)),
        picocolors_1.default.red(`because:`)
    ].join(' ');
    return msg;
}
/** `filePath.filePathToShowToUser` may show the import path of a package, use `filePathToShowToUser2` instead always show a file path instead. */
function getFilePathToShowToUser2(filePath) {
    const { filePathAbsoluteFilesystem, filePathRelativeToUserRootDir } = filePath;
    const filePathToShowToUser2 = filePathRelativeToUserRootDir || filePathAbsoluteFilesystem;
    (0, utils_js_1.assert)(filePathToShowToUser2);
    return filePathToShowToUser2;
}
